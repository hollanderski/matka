<!DOCTYPE html>
<html>
<!-- https://velasquezdaniel.com/blog/rendering-100k-spheres-instantianing-and-draw-calls/ -->

<head>
    <meta charset="utf-8">

    <style>


    @font-face {
  font-family: "myfont";
  src: url("king.ttf");
}
        body {
            margin: 0;
        }

        #poem {
  position: absolute;
            top: 50%;
            left: 10%;
            width: 80%;
            height: 80%;
            background-color: rgba(76, 175, 80, 0.) ;/* #f00;*/
            padding: 3%;
            text-align: center;
            color: #fff;
            box-sizing: border-box;
            font-size: 40px;
            font-family: "myfont";
}

.fadeanim.visible{
  animation-name: fade;
  animation-fill-mode: none; /*both */
  animation-iteration-count: 1;
  animation-duration: 2s; /* 5s */
  animation-direction: reverse;/*alternate-reverse; */ 
}

.visible {
  visibility: visible;
}

.not-visible {
  visibility: hidden;
}


@keyframes fade{
    0%,50% {
      opacity: 1;
}
    100%{
      opacity: 0;
  }
}

</style>
</head>

<body>
<div style="position:absolute; width:50%; display:none" id="status"></div>
<input id="slider" type="range" min="0.0001" max="1" step="0.0001" value="0." style="display: none; position:absolute;width:300px;">
        <div id="myscene"></div>
        <div id="poem"></div>

    <script src="js/three.min.js"></script>
    <script type="text/javascript" src="js/GPUComputationRenderer.js"></script>
    <script type="text/javascript" src="js/OrbitControls.js"></script>
    <!--<script src="js/OBJLoader.js"></script>-->
    <script src="js/postprocessing.min.js"></script>
    <script src="js/ml5.min.js"></script>
    <!-- https://jsfiddle.net/hbarone/n1yxsLt6/59/ -->



    <script id="vshader" type="x-shader/x-vertex">

        #define PI 3.14


        precision highp float;
        uniform float time;


        attribute vec3 translate;
        attribute vec3 torus;
        //attribute vec3 knot;
        //attribute vec3 bird;
        attribute vec2 reference;


        varying vec2 vUv;
        varying float vScale;
        varying vec3 tmpPos;
        varying vec4 mvPosition;

        varying vec3 vColor; 
        attribute vec3 color;

        uniform float interpolation;
        uniform float radius;
        uniform int state;

        attribute float phi;
        attribute float theta;
        attribute float speed;
        attribute float amplitude;
        attribute float frequency;


        vec3 rtp2xyz(){ // the magic is here
         float tmpTheta = theta + time * speed;
         float tmpPhi = phi + time * speed;
         float r = sin(time * frequency) * amplitude * sin(interpolation * 3.1415926);
         float x = sin(tmpTheta) * cos(tmpPhi) * r;
         float y = sin(tmpTheta) * sin(tmpPhi) * r;


         float z = cos(tmpPhi) * r;
         return vec3(x, y, z);
        }

        float sigmoid(float x) {
          if (x >= 1.0) return 1.0;
          else if (x <= -1.0) return 0.0;
          else return 0.5 + x * (1.0 - abs(x) * 0.5);
        }


        uniform sampler2D texturePosition;


        void main() {

            vColor = color;


            //vec3 tmpPos = texture2D( texturePosition, reference ).xyz;
            // mix(position, normalize(position) * radius, interpolation); 


            //  interpolation between 2 meshes
            if(state == 1 ){

                tmpPos = mix ( texture2D( texturePosition, reference ).xyz,  torus, interpolation);

            }
            else if(state == 2){

                
                tmpPos = mix ( texture2D( texturePosition, reference ).xyz,  translate, interpolation);

            }
            else if(state == 3){ // 

                tmpPos = mix ( texture2D( texturePosition, reference ).xyz,  translate, interpolation);

            }
            else if(state == 4){ // 

                tmpPos = mix ( texture2D( texturePosition, reference ).xyz,  translate, interpolation);

            }
            else if(state == 5){ // 

                tmpPos = mix ( texture2D( texturePosition, reference ).xyz,  translate, interpolation);

            }
           else if(state >= 6 && state<11){ 


                tmpPos = mix ( texture2D( texturePosition, reference ).xyz,  translate, interpolation);

            }
            else if(state==11){ 


                tmpPos = mix ( texture2D( texturePosition, reference ).xyz,  torus, interpolation);

            }
            else if(state==12){ 


                tmpPos = mix ( texture2D( texturePosition, reference ).xyz,  translate, interpolation);

            }

            //tmpPos = mix (knot, texture2D( texturePosition, reference ).xyz, interpolation);
                //tmpPos = mix (knot, translate, interpolation);
                //tmpPos = mix (bird, texture2D( texturePosition, reference ).xyz, interpolation);
                /*
                //tmpPos.y =sigmoid(tmpPos.y);// sin(time *(6.284/360.0));
                //tmpPos.x = sigmoid(tmpPos.x); -> plan donc peut être mer, sinon les deux carré fenêtre?*/
                //tmpPos.x = sin(time*0.5); 
                //tmpPos.y = sin(time*0.5);  // pour les ailes


            // La mer
            if(state>=7 && state<=11)
            {
                float s_contrib = 0.6*sin(tmpPos.x*2.5 + 0.2* time);
                float t_contrib = 0.8*cos(tmpPos.y*4.1 + 0.5* time);
                float height = s_contrib*t_contrib;
                mvPosition = modelViewMatrix * vec4(vec3(tmpPos.xy, height), 1.0 ); 

            }
            else
                mvPosition = modelViewMatrix * vec4( tmpPos, 1.0 ); // translate pour aucun mouvement au lieu de tempPos
            

            vec3 trTime = vec3(tmpPos.x + time,tmpPos.y + time,tmpPos.z + time);
            float scale =  sin( trTime.x * 2.1 ) + sin( trTime.y * 3.2 ) + sin( trTime.z * 4.3 ); //2.1
            vScale = scale;
            scale = scale * 1. + 2.;//10.0;
        
            mvPosition.xyz += (position) * scale;


            vUv = uv;

            gl_PointSize = 1. * ( 1. / length( mvPosition.xyz ) );
            gl_Position = projectionMatrix * mvPosition;

            

        }
    </script>
    <script id="fshader" type="x-shader/x-fragment">


        varying vec3 vNormal; 
        varying vec3 vColor;

        precision highp float;

        uniform sampler2D map;
        uniform int music;
        uniform int state;


        varying vec2 vUv;
        varying float vScale;

        // HSL to RGB Convertion helpers
        vec3 HUEtoRGB(float H){
            H = mod(H,1.0);
            float R = abs(H * 6.0 - 3.0) - 1.0;
            float G = 2.0 - abs(H * 6.0 - 2.0);
            float B = 2.0 - abs(H * 6.0 - 4.0);
            return clamp(vec3(R,G,B),0.0,1.0);
        }

        vec3 HSLtoRGB(vec3 HSL){
            vec3 RGB = HUEtoRGB(HSL.x);
            float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;
            return (RGB - 0.5) * C + HSL.z;
        }

        void main() {
      

                gl_FragColor = vec4(vColor, 1.);

                vec4 diffuseColor = gl_FragColor * texture2D( map, vUv);

                gl_FragColor = vec4( diffuseColor.xyz * HSLtoRGB(vec3(vScale/2.0, 1.0, 1)), diffuseColor.w );

                if ( diffuseColor.w < 0.5 ) discard;


        }
    </script>



    <script id="fragmentSimulation" type="x-shader/x-fragment">

        #define USE_MAP

uniform float time;
uniform float delta;
uniform sampler2D texturePosition;

uniform int state;

// curl noise variation
//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//

vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
    return mod289(((x*34.0)+1.0)*x);
}

float noise(vec2 v)
{
    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
    // First corner
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);

    // Other corners
    vec2 i1;
    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
    //i1.y = 1.0 - i1.x;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    // x0 = x0 - 0.0 + 0.0 * C.xx ;
    // x1 = x0 - i1 + 1.0 * C.xx ;
    // x2 = x0 - 1.0 + 2.0 * C.xx ;
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;

    // Permutations
    i = mod289(i); // Avoid truncation effects in permutation
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
        + i.x + vec3(0.0, i1.x, 1.0 ));

    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;

    // Gradients: 41 points uniformly over a line, mapped onto a diamond.
    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;

    // Normalise gradients implicitly by scaling m
    // Approximation of: m *= inversesqrt( a0*a0 + h*h );
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

    // Compute final noise value at P
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

vec3 curl(float x,  float   y,  float   z)
{

    float   eps = 1., eps2 = 2. * eps;
    float   n1, n2, a,  b;

    x += time * .05;
    y += time * .05;
    z += time * .05;

    vec3    curl = vec3(0.);

    n1  =   noise(vec2( x,  y   +   eps ));
    n2  =   noise(vec2( x,  y   -   eps ));
    a   =   (n1 -   n2)/eps2;

    n1  =   noise(vec2( x,  z   +   eps));
    n2  =   noise(vec2( x,  z   -   eps));
    b   =   (n1 -   n2)/eps2;

    curl.x  =   a   -   b;

    n1  =   noise(vec2( y,  z   +   eps));
    n2  =   noise(vec2( y,  z   -   eps));
    a   =   (n1 -   n2)/eps2;

    n1  =   noise(vec2( x   +   eps,    z));
    n2  =   noise(vec2( x   +   eps,    z));
    b   =   (n1 -   n2)/eps2;

    curl.y  =   a   -   b;

    n1  =   noise(vec2( x   +   eps,    y));
    n2  =   noise(vec2( x   -   eps,    y));
    a   =   (n1 -   n2)/eps2;

    n1  =   noise(vec2(  y  +   eps,    z));
    n2  =   noise(vec2(  y  -   eps,    z));
    b   =   (n1 -   n2)/eps2;

    curl.z  =   a   -   b;

    return  curl;
}


varying vec2 vUv;

void main() {

    
    vec2 uv = gl_FragCoord.xy / resolution.xy;


    vec4 tmpPos = texture2D( texturePosition, uv );
    vec3 pos = tmpPos.xyz;

    float f = 1.; // poussiere = 10.
    float amplitude = 0.001;

    if( state == 1){
        amplitude = 0.1;
    }
    vec3 target = pos + amplitude*curl(f*pos.x*10., f*pos.y, f*pos.z);

    gl_FragColor = vec4( target , 1. );
}


</script>

 <script type="text/javascript">

var divisions = 5;
  let word, pitch, peakDetect, audioContext, amp;
  let cnv
  var speed = 1;
  var iteration = 0
/*
function startPitch() {
  pitch = ml5.pitchDetection('./model/', audioContext , source.stream, modelLoaded);
}
*/



function modelLoaded() {
  document.getElementById('status').innerHTML+='Model Loaded'
  getPitch(pitch);
}

var tempfreq=0; 
var tim=false;
var timebetweenparagraphs=10000;
let rotationZ = false
let min_volume = 0.1


function getPitch(pitch, currvolume) {
  var p = pitch.getPitch(function(err, frequency) {
    var nextnote = tempfreq*(2**(1/12))
    var prevnote = tempfreq*(2**(-1/12))


    // Si ce n'est pas du brouhaha 
    if (currvolume>0.1 && frequency && !rotationZ){// && (frequency<=prevnote || frequency>=nextnote)){// && fft.getEnergy(frequency) > min_volume) {


        rotationZ = true;
        material.uniforms.music.value=1
        
        setTimeout(function() { 
            rotationZ=false; //delta = 0.0002; //
            material.uniforms.music.value=0;
            if(material.uniforms.state.value>= 6 || material.uniforms.state.value==1){
                dirRotation*=-1
            }
         /*   if(material.uniforms.state.value==1){
                if((slider.value<=1 && motcount==0) || (motcount>0))
                    dirRotation*=-1
            }*/
        }, 3000);

        // state 10-11 { x: 654.3247630826152, y: 769.3090940414894, z: -4.756284468438289 }

        //mesh.translateX(-10)
        //mesh.rotation.x = time * 0.25;

       // console.log("frequency", frequency)

        /*
      var coord = map(frequency, 0, windowWidth, 0, 1024)
      //text("matka", frequency,60);
      console.log(prevnote, nextnote, tempfreq, frequency, fft.getEnergy(frequency))
      if((frequency<=prevnote || frequency>=nextnote) && poem[iteration]!="")
        iteration++; // Si la note est différente de la précédente, mot suivant

      //textSize(0.01*fft.getEnergy(frequency)**2);
      if(poem[iteration]=="" && !tim){
        tim=true
        setTimeout(function() { iteration++; tim=false;}, timebetweenparagraphs);

      }
      else if(poem[iteration]!=""){
        text(poem[iteration], frequency,fft.getEnergy(frequency));
      }

      */

      //select('#result').html(frequency);
    } else {
      //select('#result').html('No pitch detected');
      //rotationZ = false
    }
    tempfreq = frequency;
    //getPitch(pitch);
  })
}


/*
    function setup() {
      amp = new p5.Amplitude();
      audioContext = getAudioContext();
      source = new p5.AudioIn();
      source.start(startPitch);
      //fft = new p5.FFT(0.9, 1024);
      //fft.setInput(source);
      //source.start(startPitch);
      //peakDetect = new p5.PeakDetect();
}

*/

var meter = null;


function createAudioMeter(audioContext, clipLevel, averaging, clipLag) {
  const processor = audioContext.createScriptProcessor(512)
  processor.onaudioprocess = volumeAudioProcess
  processor.clipping = false
  processor.lastClip = 0
  processor.volume = 0
  processor.clipLevel = clipLevel || 0.98
  processor.averaging = averaging || 0.95
  processor.clipLag = clipLag || 750

  // this will have no effect, since we don't copy the input to the output,
  // but works around a current Chrome bug.
  processor.connect(audioContext.destination)

  processor.checkClipping = function () {
    if (!this.clipping) {
      return false
    }
    if ((this.lastClip + this.clipLag) < window.performance.now()) {
      this.clipping = false
    }
    return this.clipping
  }

  processor.shutdown = function () {
    this.disconnect()
    this.onaudioprocess = null
  }

  return processor
} 

function volumeAudioProcess(event) {

  const buf = event.inputBuffer.getChannelData(0)
  const bufLength = buf.length
  let sum = 0
  let x

  // Do a root-mean-square on the samples: sum up the squares...
  for (var i = 0; i < bufLength; i++) {
    x = buf[i]
    if (Math.abs(x) >= this.clipLevel) {
      this.clipping = true
      this.lastClip = window.performance.now()
    }
    sum += x * x
  }

  // ... then take the square root of the sum.
  const rms = Math.sqrt(sum / bufLength)

  // Now smooth this out with the averaging factor applied
  // to the previous sample - take the max here because we
  // want "fast attack, slow release."
  this.volume = Math.max(rms, this.volume * this.averaging)
  //document.getElementById('audio-value').innerHTML = this.volume
  //console.log("VOLUME", this.volume)

  getPitch(pitch, this.volume)
}



const handleSuccess = function(stream) {
    console.log("succesok")
    const context = new AudioContext();
    const source = context.createMediaStreamSource(stream);
    //const processor = context.createScriptProcessor(1024, 1, 1);

    //source.connect(processor);
    //processor.connect(context.destination);

    meter = createAudioMeter(context)
    source.connect(meter)


    function startPitch() {
      pitch = ml5.pitchDetection('./model/', context , stream, modelLoaded);
    }

    startPitch();

  };

  navigator.mediaDevices.getUserMedia({ audio: true, video: false })
      .then(handleSuccess);



 





  </script>

<script type="text/javascript">

    var index = 0;
    let interval;
    var words = ["Teraz,", 
    "kiedy pisze te słowa,", 
    "oczy matki spoczywają na mnie.",
    "",
    "Te oczy, uważne i czujnie pytają milcząc", "\"co cię martwi synku...?\"" ,"",
    "Odpowiadam z uśmiechem","\"nic...","wszystko w porządku, naprawdę, Mamo\",",
    "\"no powiedz –&nbsp;mówi&nbsp;Matka&nbsp;– co cie trapi?\"" ,"Odwracam głowę, patrzę przez okno","",
    "Oczy matki wszystko widzące",
    "patrzą na urodziny",
    "patrzą przez całe życie",
    "i patrzą po śmierci z \"tamtego świata\".",
    "Nawet jeśli syn",
    "zamieniony został w maszynę do zabijania",
    "albo zwierzę mordercę",
    "oczy matki patrzą na niego z miłością...",
    "patrzą.","",
    "Kiedy matka odwróci oczy od swojego dziecka,",
    "dziecko zaczyna błądzić",
    "i ginie w świecie pozbawionym miłości i ciepła", "","","",
// avant, break 1/2
// ici break long et texte plus rapide 
// ensuite break 1/2
    "Przez wiele lat obiecywałem Mamie trzy rzeczy,",
    "że zaproszę ją do Krakowa,",
    "że pokażę Zakopane i góry,",
    "że pojadę z Mamą nad morze.", "",

    "Mama nie zobaczyła nigdy w życiu Krakowa.",
    "Nie widziała ani Krakowa ani gór",
    "(z&nbsp;Morskim&nbsp;Okiem&nbsp;w&nbsp;środku)",
    "ani morza.",
    "Nie dotrzymałem obietnic...",""
    ,
    "Minęło od śmierci Mamy prawie pół wieku...",
    "Czemu Jej nie zawiozłem do Krakowa i nie pokazałem Sukiennic,",
    "kościoła Mariackiego,",
    "Wawelu... Wisły.","",
    "Mama nie widziała Warszawy.",
    "Mama nigdy nie leciała samolotem,",
    "nie płynęła statkiem.",
    "Nigdy nie byłem z Mamą w cukierni, w restauracji, w kawiarni, w teatrze, operze...",
    "Ani na koncercie...",
    "byłem poetą...","",

    "Nie zawiozłem Mamy nad morze...",
    "nie usiadłem z nią nad brzegiem,",
    "nie przyniosłem muszelki albo bursztynowego kamyczka.",
    "Nic...",
    "i ona nigdy nie zobaczy morza...",
    "i nigdy nie zobaczę jej Twarzy i oczu i uśmiechu kiedy patrzy na morze...",
    "poeta." , "","",""
    ]
// directly to birds
    var words2 = [
"Odwróciła twarz do ściany", // la porte  ? toujours lumière + texte ? 
"przecież mnie kocha", 
"dlaczego odwróciła się ode mnie",
"więc takim ruchem głowy", 
"można odwrócić się od świata", 
"na którym ćwierkają wróble",
 "i młodzi ludzie chodzą", 
"w krzyczących krawatach", 
"Ona jest teraz sama", 
"w obliczu martwej ściany",
"i tak już zostanie", 
"zostanie pod ścianą",
 "ogromniejącą", 
"skręcona i mała", 
"z zaciśniętą pięścią", 
"a ja siedzę", 
"z kamiennymi nogami", 
"i nie porywam jej z tego miejsca", 
"nie unoszę", 
"lżejszej niż westchnienie",//"", // Ici lancer birds
/*"Kiedy zamknę oczy to słyszę", 
"Głos ptaka skrzyp sosen",  
"Lasu płytką ciszę", 
"Zmąconą naszym śmiechem", 
"Widzę las gdzie z wami",
"Zbierałem jagody", 
"Ciało wtenczas było ruchliwe", 
"I młode jak wody", 
"Wracaliśmy do domu", 
"Z czarnymi ustami", 
"Bose nogi jak skrzydła", 
"Świeciły uciekając w kurzu", 
"Już dom widać Dym", 
"Na niebie pełznący cierpliwie", 
"I matkę w oknie", 
"Z dłonią nad oczami","",
"W ciemnym pokoju",
 "na stole stoi kieliszek", 
"czerwonego wina", 
"przez otwarte drzwi", 
"widzę krajobraz dzieciństwa", 
"kuchnię z niebieskim czajnikiem",
 "serce Jezusa w cierniowej koronie",
 "przeźroczysty cień matki", 
"w okrągłej ciszy",
 "pianie koguta", 
"pierwszy grzech", 
"białe ziarnko w zielonym", 
"owocu miękkie", 
"gorzkawe", 
"pierwszy diabeł różowy", 
"poruszający półkulami", 
"pod jedwabną suknią", 
"w groszki",
 "uchylają się", 
"w oświetlonym krajobrazie", 
"trzecie drzwi", 
"a za nimi we mgle", 
"w głębi",
 "trochę w lewo",
 "albo w środku",
 "widzę", 
"Nic", "",
"Patrzę przez okno", 
"w różowych kwiatkach", 
"na dworze koty mokną", 
"i moja stara matka", 
"czerpie żółtą wodę", 
"rękami świętej", 
"w oknie stoi jej młode", 
"źle uśmiechnięte","",
 "Nagle otworzy się okno",
 "i matka mnie zawoła", 
"już czas wracać", 
"rozstąpi się ściana", 
"wejdę do nieba w zabłoconych butach", 
"usiądę przy stole i opryskliwie", 
"będę odpowiadał na pytania", 
"nic mi nie jest", 
"dajcie mi spokój.", 
"Z głową w dłoniach tak siedzę i siedzę.",
 "Jakże im opowiem o tej długiej i splątanej drodze.", 
"Tu w niebie matki robią", 
"zielone szaliki na drutach", 
"brzęczą muchy",
"ojciec drzemie pod piecem",
 "po sześciu dniach pracy.", 
"Nie - przecież nie mogę im",
 "powiedzieć że człowiek człowiekowi", 
"skacze do gardła" */

    ]

    var motcount = -1;
    var timeParagraph = 40000/2; //60000;
    var timeWord = timeWordTemp = 1200
    var timeSentence = 2000;//timeWord*5
    var shadowing=false;
    var message ="";
    var interlude = false;
    var interludeback = false;
/*
    if(poem[iteration]=="" && !tim){
    tim=true
    setTimeout(function() { iteration++; tim=false;}, timebetweenparagraphs);

    }
    else if(poem[iteration]!=""){
    text(poem[iteration], frequency,fft.getEnergy(frequency));
    }


*/



 function launchAnim(maxval){

    if(interlude){

        if(slider.value<maxval && !interludeback){
            slider.value=(parseFloat(slider.value)+0.001).toString()
        }
        else{
            interludeback=true;
            slider.value= (Math.max(0.0001,parseFloat(slider.value)-0.001)).toString()
            if(parseFloat(slider.value)==0.0001){

                // fin de l'interlude
                if(interlude){
                    material.uniforms.state.value++;
                    console.log("state", material.uniforms.state.value);
                    if(material.uniforms.state.value== 7){

                         mesh.rotateY(400);
                         mesh.translateY(300);

                    }

                    //if(state==2)
                    //    camera.position.set(654,769,-4)
                    // state 10-11 { x: 654.3247630826152, y: 769.3090940414894, z: -4.756284468438289 }

                }

                interlude=false;
                interludeback=false;
                
            }
        } 

    }

 }



 function shortinterlude(maxval){


        if(slider.value<maxval && dirRotation==1){
            slider.value=(parseFloat(slider.value)+0.001).toString()
        }
        else if(slider.value>0.0001 && dirRotation==-1){
            slider.value= (Math.max(0.0001,parseFloat(slider.value)-0.001)).toString()
        } 
 }

 //  x: 1271.118918102989, y: 407.3781463773532, z: 1031.3097283364666 }
// wait 3 second before back 

 function extraire(){


    if(motcount==0){

        // rétablissement du pas de temps mot
        timeWord=timeWordTemp;

        document.getElementById("poem").innerHTML="";
            
            message = words[index].split(/(\s+)/); 

            message.forEach(mot => {
                document.getElementById("poem").innerHTML +='<span class="not-visible">' +mot+ '</span>';
            }); // not-visible
    }

                if( motcount < message.length){
                 
                // On incremente i et on compare a la taille du message.
                    // Si i ne depasse pas le nombre de caracteres dans le message
                    // Note : le premier caractere de la chaine commence a l'index 0
                    if( message[motcount] == '\n' ||  message[motcount] == "" ){
                        // Si saut de ligne on remplace par l'equivalent HTML : "<br/>".
                        document.getElementById("poem").innerHTML += '<br/>';

                        if(message[motcount] == ""){
                            // passage au prochain paragraphe
                            console.log("nouveau timeParagraph")
                            motcount=0;
                            interlude = true;
                            index++;

                            // attendre avant jesus
                            if(index>=words.length && !shadowing){

                                console.log("nouveau poeme")

                                    index=0;
                                    words=words2;
                                    shadowing=true;
                                    timeSentence=1000;
                                    timeWord=1000; //
                                    jesus.scale.x=0.2
                                    jesus.scale.y=0.2
                                    jesus.scale.z=0.2;
                                    jesus.scale.set(0.000002,0.000002,0.000002)
                                    jesus.visible=true;
                                    jesus.translateZ(-1000)


                                
                                // ici changer texte et lancer le shadowing
                                //clearTimeout(interval);
                            }

                            setTimeout(extraire, timeParagraph);
                        }

                    } else {


                        if(document.querySelectorAll('span')[motcount]){
                            if(document.querySelectorAll('span')[motcount-1]){
                                document.querySelectorAll('span')[motcount-1].classList.remove("fadeanim");
                            }
                    
                            if(shadowing)
                                document.querySelectorAll('span')[motcount].style["animation-duration"] ="1s";
                            document.querySelectorAll('span')[motcount].classList.add("fadeanim");
                            document.querySelectorAll('span')[motcount].classList.add("visible");
                            document.querySelectorAll('span')[motcount].classList.remove("not-visible");

                        }
                    
                        // passage au prochain mot
                        motcount++;
                        setTimeout(extraire, timeWord); 
                    }



                } else {
                    // Sinon change de phrase

                    if(words[index]=="lżejszej niż westchnienie"){
                        document.location="musicbird.html";
                    }
                    // error

                    index++;
                    motcount=0;
                    

                    console.log("change",index, words.length, index>=words.length,  index==62)
                    
                    
                    setTimeout(extraire, timeSentence);

                }
            }
             
            // On incremente i en debut de fonction, il vaudra donc 0 a la premiere execution.
        
// a preset that I like for jesus  part 2 : { x: 100, y: 10, z: 0 }
// for the camera part 2 Object { x: 348.59516333718176, y: 524.0056932661672, z: 541.748748445195 }

    function poetry(){
        
    
            motcount = 0;
            var stop = false;

             // Loop on words


            setTimeout(function(){

                stop = true; 
                interval = setTimeout(extraire, timeWord);

            }, 210000) 
            


        setInterval(function(){

            console.log("allez on augmente")
            if(mesh.geometry.instanceCount<75000){


                mesh.geometry.instanceCount+=8000;

            }
        },
        280000)
    }

    poetry();


</script>

    <script>

// camera mer :  Object { x: 783.0342149070423, y: 554.3460349009379, z: 10.387101352834648 }
// camera fenetre : Object { x: 260.1867191519565, y: 275.8385476581119, z: -1643.6289060093336 } 

        slider.value="0.0001";
        const BOUNDS = 10, BOUNDS_HALF = BOUNDS / 2;


        const scene = new THREE.Scene();

        scene.add(new THREE.AmbientLight(0x333333));

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);

        const myscene = document.getElementById("myscene")
        //document.body
        myscene.appendChild(renderer.domElement);


        var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.z = 1000;//5000;
        camera.position.x = 100;
        camera.position.y = 100;

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.update();
        controls.minDistance = 0; // proximité mesh
        controls.maxDistance = 5000;




        var light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 3, 5);
        scene.add(light);



        var sphere_geometry
        var material;
        var sphere;


        // FBO particles
        const WIDTH = 128;
        initGPGPU();

        function initGPGPU() {


            gpuCompute = new THREE.GPUComputationRenderer(WIDTH, WIDTH, renderer)
            const dtPosition = gpuCompute.createTexture();
            fillPositions(dtPosition)
            positionVariable = gpuCompute.addVariable('texturePosition', document.getElementById('fragmentSimulation').textContent, dtPosition)
            positionVariable.material.uniforms['time'] = {
                value: 0.0
            };
            positionVariable.material.uniforms['delta'] = {
                value: 0.0
            };
            positionVariable.wrapS = THREE.RepeatWrapping;
            positionVariable.wrapT = THREE.RepeatWrapping;
            const error = gpuCompute.init();

            if (error !== null) {

                console.error(error);

            }

        }


        // ================== LIGHT & POSTPROCESSING ================= /

        let colorval = 255
        let jesus

        const geometryy = new THREE.SphereGeometry(15, 32, 16);
        const materiall = new THREE.MeshBasicMaterial({
            color: 0xffffff
        });
        jesus = new THREE.Mesh(geometryy, materiall);
        jesus.position.set(0, 0, 0);
        scene.add(jesus);

        jesus.visible = false;


        const godraysOptions = {
            resolutionScale: 1,
            blurriness: 0,
            density: 10.8,
            decay: 0.92,
            weight: 0.45,
            exposure: 0.75,
            samples: 100
        };

        composer = new POSTPROCESSING.EffectComposer(renderer);

        const renderPass = new POSTPROCESSING.RenderPass(scene, camera);

        const godraysEffect = new POSTPROCESSING.GodRaysEffect(camera, jesus, godraysOptions);

        godRaysPass = new POSTPROCESSING.EffectPass(camera, godraysEffect);

        godRaysPass.renderToScreen = true;

        composer.addPass(renderPass);
        composer.addPass(godRaysPass);



        // =============== BUFFER GEOMETRY & PARTICLES ============= /


        // Initial position

        function fillPositions(texture) {
            // radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float
            // radius 1 et 3 ok
            var model2 = new THREE.TorusBufferGeometry(3., 1., 100, WIDTH * WIDTH);
            
            var facePos = model2.attributes.position.array;

            var faceNumber = facePos.length / 3;


            let arr = texture.image.data;


            for (let i = 0; i < arr.length; i += 4) {

                let rand = Math.floor(Math.random() * faceNumber)
               
                let x = Math.random()// * BOUNDS - BOUNDS_HALF;
                let y = Math.random() //* BOUNDS - BOUNDS_HALF;
                let z = Math.random()//* BOUNDS - BOUNDS_HALF;
                
/*
                let x = facePos[3 * rand]
                let y = facePos[3 * rand + 1]
                let z = facePos[3 * rand + 2]
 */   

                arr[i] = x;
                arr[i + 1] = y;
                arr[i + 2] = z;
                arr[i + 3] = 1;
            }

        }




        const circleGeometry = new THREE.CircleGeometry(1, 32);

        const geometry = new THREE.InstancedBufferGeometry();
        geometry.index = circleGeometry.index;
        geometry.attributes = circleGeometry.attributes;
        geometry.computeVertexNormals();

        const particleCount = WIDTH * WIDTH; //75000;

        const translateArray = new Float32Array(particleCount * 3);
        let reference = new Float32Array(particleCount * 2);

        for (var i = 0; i < particleCount; i++) {

            

            translateArray[i + 0] = Math.random() * 10 - 1; // 50
            translateArray[i + 1] = Math.random() * 100 - 1; //200
            translateArray[i + 2] = Math.random() * 50 - 1; // 100

            

            // uvs
            let xx = (i % WIDTH) / WIDTH;
            let yy = ~~(i / WIDTH) / WIDTH;

            reference.set([xx, yy], i * 2);

        } 

        geometry.setAttribute('translate', new THREE.InstancedBufferAttribute(translateArray, 3));
 


        let mytorus = new Float32Array( WIDTH * WIDTH * 3);
        let tor 


        tor = new THREE.TorusBufferGeometry(3., 1., 100, WIDTH * WIDTH).attributes.position.array;

        let faceNumber = tor.length / 3;

         for (var i = 0; i <  WIDTH * WIDTH; i+=3) {

            let rand = Math.floor(Math.random() * faceNumber)
            

            mytorus[i + 0] = tor[3* rand]
            mytorus[i + 1] = tor[3* rand+1]
            mytorus[i + 2] = tor[3* rand+2]


        } 

        geometry.setAttribute('torus', new THREE.InstancedBufferAttribute(mytorus, 3));

/*
        let knot = new Float32Array( WIDTH * WIDTH * 3);
        tor =  new THREE.SphereBufferGeometry(3, 100., 50, WIDTH * WIDTH).attributes.position.array;

        faceNumber = tor.length / 3;

         for (var i = 0; i <  WIDTH * WIDTH; i+=3) {

            rand = Math.floor(Math.random() * faceNumber)

            knot[i + 0] = tor[3* rand]
            knot[i + 1] = tor[3* rand + 1]
            knot[i + 2] = tor[3* rand + 2]

        } 

        geometry.setAttribute('knot', new THREE.InstancedBufferAttribute(knot, 3)); */


        // uvs
        geometry.setAttribute('reference', new THREE.InstancedBufferAttribute(reference, 2));





var attrPhi = new Float32Array( geometry.attributes.position.count );
var attrTheta = new Float32Array( geometry.attributes.position.count );
var attrSpeed = new Float32Array( geometry.attributes.position.count );
var attrAmplitude = new Float32Array( geometry.attributes.position.count );
var attrFrequency = new Float32Array( geometry.attributes.position.count );
for (var attr = 0; attr < geometry.attributes.position.count; attr++){
  attrPhi[attr] = Math.random() * Math.PI * 2;
  attrTheta[attr] = Math.random() * Math.PI * 2;
  attrSpeed[attr] = THREE.Math.randFloatSpread(6);  
  attrAmplitude[attr] = Math.random() * 5;
  attrFrequency[attr] = Math.random() * 5;
}
geometry.addAttribute( 'phi', new THREE.InstancedBufferAttribute( attrPhi, 1 ) );
geometry.addAttribute( 'theta', new THREE.InstancedBufferAttribute( attrTheta, 1 ) );
geometry.addAttribute( 'speed', new THREE.InstancedBufferAttribute( attrSpeed, 1 ) );
geometry.addAttribute( 'amplitude', new THREE.InstancedBufferAttribute( attrAmplitude, 1 ) );
geometry.addAttribute( 'frequency', new THREE.InstancedBufferAttribute( attrFrequency, 1 ) );




        // cf https://jsfiddle.net/prisoner849/z3yfw208/
        mytexture = new THREE.TextureLoader().load("ball.png", t => {
            t.center.setScalar(0.5);
            t.rotation = -Math.PI * 0.5;
        });
        mytexture.mapping = THREE.SphericalReflectionMapping;

        var phongShader = THREE.ShaderLib.phong;
        var uniforms = THREE.UniformsUtils.clone(phongShader.uniforms)

        var myuniform = ({
            map: {
                value: mytexture
            },
            texturePosition: {
                value: null
            },
            delta: {
                value: 0.0
            },
            resolution: {
                type: 'v4',
                value: new THREE.Vector4()
            },

            interpolation: { value: slider.value},
            radius: { value: 7.5},
            color: { value: new THREE.Color(0x00ff00)},
            time: { value: 0 },
            state: { type: "d", value : 1 },
            music: { type: "d", value : 0 }
        });



        material = new THREE.ShaderMaterial({
            uniforms: myuniform,
            vertexShader: document.getElementById('vshader').textContent,
            fragmentShader: document.getElementById('fshader').textContent,
            depthTest: true,
            depthWrite: true,
            roughness: 1,
            fog: true,
            extensions: {
                derivatives: '#extension GL_OES_standard_derivatives :enable',
            }
        });



        mesh = new THREE.Mesh(geometry, material);
        mesh.geometry.instanceCount=10;
        mesh.scale.set(500, 500, 500);
        scene.add(mesh);


/*

     const loader = new THREE.OBJLoader();

        // this utility function allows you to use any three.js
        // loader with promises and async/await
        function modelLoader(url) {
          return new Promise((resolve, reject) => {
            loader.load(url, data=> resolve(data), null, reject);
          });
        }

    async function main() {
       const gltfData = await modelLoader("colombe.obj"), //eye4 falcon
       model = gltfData;
      
       tor=model.children[0].geometry.attributes.position.array


       faceNumber = tor.length / 3;

         for (var i = 0; i <  WIDTH * WIDTH; i+=3) {

            let rand = Math.floor(Math.random() * faceNumber)
            

            mytorus[i + 0] = tor[3* rand] * 5.
            mytorus[i + 1] = tor[3* rand+1]  * 5.
            mytorus[i + 2] = tor[3* rand+2]  * 5.

        } 

        geometry.setAttribute('bird', new THREE.InstancedBufferAttribute(mytorus, 3));

       
    }

    main().catch(error => {
      console.error(error);
    });

*/





        var clock = new THREE.Clock();
        clock.start();

        function getStepSize(filterLen, tapsPerPass, pass) {

            return filterLen * Math.pow(tapsPerPass, -pass);

        }

        function filterGodRays(inputTex, renderTarget, stepSize) {

            postprocessing.scene.overrideMaterial = postprocessing.materialGodraysGenerate;

            postprocessing.godrayGenUniforms["fStepSize"].value = stepSize;
            postprocessing.godrayGenUniforms["tInput"].value = inputTex;

            renderer.setRenderTarget(renderTarget);
            renderer.render(postprocessing.scene, postprocessing.camera);
            postprocessing.scene.overrideMaterial = null;

        }


var timeVal = 0
var time
var delta=0.0002
var dirRotation = 1

        const animate = function() {


            time = Date.now() * 0.0005; //const

/*
            mesh.rotation.x = time * 0.25;
            mesh.rotation.y = time * 0.2;
*/

            // Animation sonore

            if(rotationZ){ 

                if(material.uniforms.state.value==5 || material.uniforms.state.value== 6){
                    mesh.rotation.z = dirRotation * time * 0.0000005 * delta; 
                    mesh.rotation.x=0;
                    mesh.rotation.y=0;
                } //|| material.uniforms.state.value==1)
                if(material.uniforms.state.value==4){
                    mesh.rotation.z =0;
                    mesh.rotation.x =0;
                    mesh.rotation.y = dirRotation * time * 0.0000005 * delta;
                }
                if(material.uniforms.state.value==3 || material.uniforms.state.value==2){
                    mesh.rotation.z = 0;
                    mesh.rotation.y = 0;
                    mesh.rotation.x = dirRotation * time * 0.0000005 * delta; 
                }
                /*if(material.uniforms.state.value== 6){
                    mesh.rotation.z = 0;
                    mesh.rotation.y = 0;
                    mesh.rotation.x = dirRotation * time * 0.0000005 * delta;
                    

                } */
                if(material.uniforms.state.value== 9){ // test
                   /* mesh.rotation.y = 0;
                    mesh.rotation.x = 0;
                    mesh.rotation.z = time * 0.0000005 * delta; */

                }
                if(material.uniforms.state.value== 9 || material.uniforms.state.value==1 || material.uniforms.state.value==12 || material.uniforms.state.value==11 || material.uniforms.state.value==10 || material.uniforms.state.value==7 || material.uniforms.state.value==8){

                    // interpolation
                    shortinterlude(0.5);

                    mesh.rotation.z = 0;
                    mesh.rotation.y = 0;
                    mesh.rotation.x = 0;

                }
               /* if(material.uniforms.state.value==11 || material.uniforms.state.value==10 || material.uniforms.state.value==7){ 

                    // interpolation
                    shortinterlude(1.);

                } */
 

                delta+=0.000005;
           /*     
                if(delta>0.02){
                    delta=0.02
                }
                else{
                    delta+=0.000005;
                } */
            }

// mer rotateZ(-249.76)

           


            // Animation entre paragraphes

            if(interlude){
                console.log("interlude")
                launchAnim(1);
            }



            positionVariable.material.uniforms.time.value = clock.getElapsedTime();
            gpuCompute.compute();

            material.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;

            let t = clock.getElapsedTime();



            mesh.geometry.attributes.position.needsUpdate = true;
            mesh.geometry.attributes.translate.needsUpdate = true;
            material.uniforms.needsUpdate = true;
            material.needsUpdate = true;
            material.uniforms.time.value = t;

            material.uniforms.interpolation.value = slider.value;


            if(mesh.geometry.instanceCount<75000)
                mesh.geometry.instanceCount+=0.05;


            if(shadowing){

                var maxjesus = 50
                camera.position.x=100;
                camera.position.y=100;
                camera.position.z=1000;

                if(jesus.scale.x < maxjesus){

                    jesus.scale.x+=0.02
                    jesus.scale.y+=0.02
                    jesus.scale.z+=0.02;

                }
                if(jesus.scale.x>=maxjesus){
                    shadowing=false;
                    renderer.setClearColor( 0xffffff, 1 );
                    jesus.visible=false;
                }


            
                
/*
                if(camera.position.x > -0.0159)
                    camera.position.x-=0.5;
                if(camera.position.z > 18){
                    //camera.position.z-=10;
                    if(camera.position.z < 400)
                        camera.position.z-=20;
                    else
                        camera.position.z-=10;
                }
                if(camera.position.y > 35){
                    if(camera.position.z < 400)
                        camera.position.y-=0.5;
                    else
                        camera.position.y-=0.01;
                } */
                if(colorval > 0){
                    colorval-=0.5;
                    document.getElementById("poem").style.color= 'rgb(' + colorval + ',' + colorval + ',' + colorval + ')';
                }
            
            }

            composer.render();

            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        };


        animate();
    </script>
</body>

</html>

<script type="text/javascript">
/*
var sideLenght = 10;
var sideDivision = 50;
var cubeGeom = new THREE.BoxBufferGeometry(sideLenght, sideLenght, sideLenght, sideDivision, sideDivision, sideDivision);
var attrPhi = new Float32Array( cubeGeom.attributes.position.count );
var attrTheta = new Float32Array( cubeGeom.attributes.position.count );
var attrSpeed = new Float32Array( cubeGeom.attributes.position.count );
var attrAmplitude = new Float32Array( cubeGeom.attributes.position.count );
var attrFrequency = new Float32Array( cubeGeom.attributes.position.count );
for (var attr = 0; attr < cubeGeom.attributes.position.count; attr++){
    attrPhi[attr] = Math.random() * Math.PI * 2;
  attrTheta[attr] = Math.random() * Math.PI * 2;
  attrSpeed[attr] = THREE.Math.randFloatSpread(6);  
  attrAmplitude[attr] = Math.random() * 5;
  attrFrequency[attr] = Math.random() * 5;
}
cubeGeom.addAttribute( 'phi', new THREE.BufferAttribute( attrPhi, 1 ) );
cubeGeom.addAttribute( 'theta', new THREE.BufferAttribute( attrTheta, 1 ) );
cubeGeom.addAttribute( 'speed', new THREE.BufferAttribute( attrSpeed, 1 ) );
cubeGeom.addAttribute( 'amplitude', new THREE.BufferAttribute( attrAmplitude, 1 ) );
cubeGeom.addAttribute( 'frequency', new THREE.BufferAttribute( attrFrequency, 1 ) );

var shaderMat = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vertexShader,
  fragmentShader: fragmentShader,
  //wireframe: true
});
var points = new THREE.Points(cubeGeom, shaderMat);
scene.add(points);

var clock = new THREE.Clock();
var timeVal = 0;

render();
function render(){
    timeVal += clock.getDelta();
    requestAnimationFrame(render);
  uniforms.time.value = timeVal;
  uniforms.interpolation.value = slider.value;
  renderer.render(scene, camera);
}

*/
</script
